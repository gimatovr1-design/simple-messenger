<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Simple Messenger</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<h3>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —á–∞—Ç üëã</h3>

<div id="nickBox">
    <input id="nickInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫" autocomplete="off">
    <button onclick="setNick()">OK</button>
</div>

<div class="layout">

    <div id="users">
        <b>–û–Ω–ª–∞–π–Ω</b>
        <ul id="userList"></ul>
    </div>

    <div class="chatBox">
        <div id="chat"></div>

        <div id="emojiPanel"></div>

        <div class="inputBox">
            <button onclick="toggleEmoji()">üòÄ</button>
            <input type="file" id="fileInput" accept="image/*,video/*">
            <input id="messageInput" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ">
            <button onclick="sendMessage()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>

            <!-- üîΩ –î–û–ë–ê–í–õ–ï–ù–û: –∫–Ω–æ–ø–∫–∏ –≤–∏–¥–µ–æ—Å–≤—è–∑–∏ -->
            <button onclick="startCall()">üìπ</button>
            <button onclick="endCall()">‚ùå</button>
        </div>
    </div>

</div>

<!-- üîΩ –î–û–ë–ê–í–õ–ï–ù–û: –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
<video id="localVideo" autoplay muted playsinline
style="width:120px;border-radius:8px;margin-top:8px"></video>

<video id="remoteVideo" autoplay playsinline
style="width:220px;border-radius:8px;margin-top:8px"></video>

<script>
let myNick = "";
let users = new Set();

const emojis = "üòÄ üòÅ üòÇ ü§£ üòÉ üòÑ üòÖ üòÜ üòâ üòä üòã üòé üòç üòò üòó üòô üòö üôÇ ü§ó ü§© ü§î ü§® üòê üòë üò∂ üôÑ üòè üò£ üò• üòÆ ü§ê üòØ üò™ üò´ üò¥ üòå üòõ üòú üòù ü§§ üòí üòì üòî üòï üôÉ ü•∞ üòá ü§™ üò° üò† ü§¨ üò§ üò≠ üò¢ üò± üò® üò∞ üò≤ ü§Ø üëç üëé üëè üôå ü§ù üí™ üôè ‚ù§ üíî üíñ üíï üíØ üî• üéâ".split(" ");

let ws = new WebSocket(
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host + "/ws"
);

ws.onmessage = (event) => {
    let data;
    try { data = JSON.parse(event.data); } catch { return; }

    if (data.type === "system") {
        handleSystem(data.text);
        return;
    }

    if (data.type === "message") {
        users.add(data.nick);
        renderUsers();
        const side = data.nick === myNick ? "me" : "other";
        addMessage(data.nick, data.text, side);
    }
};

function setNick() {
    const nick = nickInput.value.trim();
    if (!nick) return;
    myNick = nick;
    ws.send("/nick " + nick);
    nickBox.style.display = "none";
}

function sendMessage() {
    const text = messageInput.value.trim();
    const file = fileInput.files[0];

    if (file) {
        const reader = new FileReader();
        reader.onload = () => ws.send(reader.result);
        reader.readAsDataURL(file);
        fileInput.value = "";
        messageInput.value = "";
        return;
    }

    if (text) {
        ws.send(text);
        messageInput.value = "";
    }
}

messageInput.addEventListener("keydown", e => {
    if (e.key === "Enter") sendMessage();
});

function addMessage(nick, text, side) {
    const msg = document.createElement("div");
    msg.className = "msg " + side;

    const avatar = document.createElement("div");
    avatar.className = "avatar";
    avatar.textContent = nick[0].toUpperCase();

    const bubble = document.createElement("div");
    bubble.className = "bubble";

    if (text.startsWith("data:image")) {
        bubble.innerHTML = `<b>${nick}</b><br>
            <img src="${text}" style="max-width:240px;border-radius:8px">`;
    }
    else if (text.startsWith("data:video")) {
        bubble.innerHTML = `<b>${nick}</b><br>
            <video src="${text}" controls playsinline
            style="max-width:240px;border-radius:8px;background:#000"></video>`;
    }
    else {
        bubble.innerHTML = `<b>${nick}</b><br>${text}`;
    }

    msg.appendChild(avatar);
    msg.appendChild(bubble);
    chat.appendChild(msg);
    chat.scrollTop = chat.scrollHeight;
}

function handleSystem(text) {
    const div = document.createElement("div");
    div.className = "system";
    div.textContent = text;
    chat.appendChild(div);
}

function renderUsers() {
    userList.innerHTML = "";
    users.forEach(u => {
        const li = document.createElement("li");
        li.innerHTML = `<span class="dot"></span>${u}`;
        userList.appendChild(li);
    });
}

function toggleEmoji() {
    emojiPanel.style.display =
        emojiPanel.style.display === "block" ? "none" : "block";
}

emojis.forEach(e => {
    const span = document.createElement("span");
    span.textContent = e;
    span.onclick = () => {
        messageInput.value += e;
        messageInput.focus();
    };
    emojiPanel.appendChild(span);
});

/* üîΩ –î–û–ë–ê–í–õ–ï–ù–û: WebRTC –≤–∏–¥–µ–æ—Å–≤—è–∑—å */
let pc;
let localStream;

const rtcWs = new WebSocket(
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host + "/webrtc"
);

rtcWs.onmessage = async e => {
    const data = JSON.parse(e.data);

    if (data.offer) {
        await pc.setRemoteDescription(data.offer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        rtcWs.send(JSON.stringify({ answer }));
    }

    if (data.answer) {
        await pc.setRemoteDescription(data.answer);
    }

    if (data.candidate) {
        await pc.addIceCandidate(data.candidate);
    }
};

async function startCall() {
    pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;

    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = e => remoteVideo.srcObject = e.streams[0];

    pc.onicecandidate = e => {
        if (e.candidate) {
            rtcWs.send(JSON.stringify({ candidate: e.candidate }));
        }
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    rtcWs.send(JSON.stringify({ offer }));
}

function endCall() {
    pc?.close();
    localStream?.getTracks().forEach(t => t.stop());
}
</script>

<style>
/* ‚¨áÔ∏è –¢–í–û–ò –°–¢–ò–õ–ò ‚Äî –ù–ï –¢–†–û–ì–ê–õ */
</style>

</body>
</html>
